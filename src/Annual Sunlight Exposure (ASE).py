"""
Perform ASE calculations, Calculate ASE and generate relevant time series data.

_
    Args:
        _studyFolder: Location of the Honeybee folder where the files for Daysim based Annual daylighting calculations exist.
        _HBObjects: List of Honeybee objects. This input should be the same as what was assigned for the annual daylighting simulation.
        _analysisRecipe: The analysis receipe that was assigned for the annual daylighting simulation.
        _illumThreshold_: Illuminance threshold for ASE calculations. Default is 1000 lux as per IES LM 83-12
        _hoursThreshold_: Number of hours per grid point to be considered for ASE calculations. Default is 250 hours lux as per IES LM 83-12
        _rcontribSettings_: Custom settings for running rcontrib. Should be in the format: -ad x -dc y -n z where x,y and z are ambient divisions,accuracy of direct calculations and number of processors respectively. Example: -ad 10000 -dc 1 -n 4
        _run: Set this to True to start the calculations.
    Returns:
        annual_ASE_analysis_file: The time-series illuminance file generated by the calculations. This file is compatible with the existing daysim, honeybee file formats.
        ASE: ASE value calculated as per _hoursThreshold_ and _illumThreshold_ values.
        hourlySummary: A list of 8760 numbers. Each number is the fraction of the total grid points that are equal to or above _illumThreshold_ at the hour cooresponding to that number. Can be visualized using the Ladybug 3-d chart.
        gridSummary: A list of numbers that represents the fraction of total hours(3650) for which a grid point is equal to or above _illumThreshold_. Can be visualized using Ladybug ReColor Mesh.
        sunPathGeometry: Radiance definition for the files generated for the sunpath calculations. Can be used for visualizing the sunpath in a radiance rendering.
"""

from __future__ import print_function

import scriptcontext as sc
import copy
import os
import Rhino as rc
import subprocess as sp

ghenv.Component.Name = "Annual Sunlight Exposure (ASE)"
ghenv.Component.NickName = "ASE"
ghenv.Component.Message = "VER 0.0.1\n03_Apr_2016"
ghenv.Component.Category = "PSUAE"
ghenv.Component.SubCategory = "Daylighting"

class hb_WriteRAD(object):
    
    def __init__(self, component = ghenv.Component):
        
        self.component = component
        
        self.hb_writeRADAUX = sc.sticky["honeybee_WriteRADAUX"]()
        self.hb_RADMaterialAUX = sc.sticky["honeybee_RADMaterialAUX"]
        self.lb_preparation = sc.sticky["ladybug_Preparation"]()
        self.hb_writeDS = sc.sticky["honeybee_WriteDS"]()
        
        self.hb_radParDict = sc.sticky["honeybee_RADParameters"]().radParDict
        
        hb_folders = sc.sticky["honeybee_folders"]
        self.hb_RADPath = hb_folders["RADPath"]
        self.hb_RADLibPath = hb_folders["RADLibPath"]
        self.hb_DSPath = hb_folders["DSPath"]
        self.hb_DSCore = hb_folders["DSCorePath"]
        self.hb_DSLibPath = hb_folders["DSLibPath"]
        
        
    def writeRADAndMaterialFiles(self, originalHBObjects, subWorkingDir, radFileName, \
                                 analysisRecipe, meshParameters, exportInteriorWalls):
        
        # initiate RAD Parameters
        if analysisRecipe.radParameters==None:
            quality = 0
            analysisRecipe.radParameters = {}
            print ("Default values are set for RAD parameters")
            for key in self.hb_radParDict.keys():
                #print key + " is set to " + str(hb_radParDict[key][quality])
                analysisRecipe.radParameters[key] = self.hb_radParDict[key][quality]
        
        # collect information from analysis recipe
        radParameters = analysisRecipe.radParameters
        simulationType = analysisRecipe.type
        
        radFileFullName = os.path.join(subWorkingDir, radFileName + '.rad')
        
        IESObjects = {}
        IESCount = 0    
        # call the objects from the lib
        hb_hive = sc.sticky["honeybee_Hive"]()
        HBObjects = hb_hive.callFromHoneybeeHive(originalHBObjects)
        
        geoRadFile = open(radFileFullName, 'w')
        geoRadFile.write("#GENERATED BY HONEYBEE\n")
        customRADMat = {} # dictionary to collect the custom material names
        customMixFunRadMat = {} # dictionary to collect the custom mixfunc material names
        surfaceList = []
        rotateObjects = False
        if len(HBObjects)!=0:
            # if this is an annual analysis and north is not 0 rotate all Honeybee objects
            if analysisRecipe.type == 2 and analysisRecipe.northDegrees!=0:
                print ("Rotating the scene for %d degrees"%analysisRecipe.northDegrees)
                
                transform = rc.Geometry.Transform.Rotation(math.radians(analysisRecipe.northDegrees), \
                            rc.Geometry.Point3d.Origin)
                rotateObjects = True
            
            for objCount, HBObj in enumerate(HBObjects):
                
                if rotateObjects: HBObj.transform(transform, False)
                
                # check if the object is zone or a surface (?)
                if HBObj.objectType == "HBZone":
                    if HBObj.hasNonPlanarSrf or HBObj.hasInternalEdge:
                        HBObj.prepareNonPlanarZone(meshParameters)
                    
                    for srf in HBObj.surfaces:
                        # check if an interior wall
                        if not exportInteriorWalls and self.hb_writeRADAUX.isSrfAirWall(srf):
                            continue
                        
                        # if it is an interior wall and the other wall is already written
                        # then don't write this wall
                        if self.hb_writeRADAUX.isSrfInterior(srf) and srf.BCObject.name in surfaceList:
                            continue
                        
                        surfaceList.append(srf.name)
                        
                        # collect the custom material informations
                        if srf.RadMaterial!=None:
                            customRADMat, customMixFunRadMat = self.hb_RADMaterialAUX.addRADMatToDocumentDict(srf, customRADMat, customMixFunRadMat)
                        # write the surfaces
                        if srf.isPlanar and len(srf.childSrfs)<2:
                            geoRadFile.write(self.RADSurface(srf))
                        else:
                            geoRadFile.write(self.RADNonPlanarSurface(srf))
                        
                        if srf.hasChild:
                            # collect the custom material informations
                            for childSrf in srf.childSrfs:
                                if childSrf.RadMaterial!=None:
                                    customRADMat, customMixFunRadMat = self.hb_RADMaterialAUX.addRADMatToDocumentDict(childSrf, customRADMat, customMixFunRadMat)
                                    
                            if not srf.isPlanar or len(srf.childSrfs) > 1:
                                geoRadFile.write(self.RADNonPlanarChildSurface(srf))
                            
                            
                elif HBObj.objectType == "HBSurface":
                    
                    # I should wrap this in a function as I'm using it multiple times with minor changes
                    # collect the custom material informations
                    if HBObj.RadMaterial!=None:
                        try:
                            customRADMat, customMixFunRadMat = self.hb_RADMaterialAUX.addRADMatToDocumentDict(HBObj, customRADMat, customMixFunRadMat)
                        except:
                            msg = HBObj.RadMaterial + " is not defined in the material library! Add the material to library and try again."
                            print (msg)
                            self.component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)
                            return -1
                            
                    # check for material in child surfaces
                    if not HBObj.isChild and HBObj.hasChild:
                        # collect the custom material informations
                        for childSrf in HBObj.childSrfs:
                            if childSrf.RadMaterial!=None:
                                try:
                                    customRADMat, customMixFunRadMat = self.hb_RADMaterialAUX.addRADMatToDocumentDict(childSrf, customRADMat, customMixFunRadMat)
                                except:
                                    msg = childSrf.RadMaterial + " is not defined in the material library! Add the material to library and try again."
                                    print (msg)
                                    self.component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)
                                    return -1                    

                    if HBObj.isPlanar and (not HBObj.isChild and len(HBObj.childSrfs)<2):
                        # check for rad material
                        geoRadFile.write(self.RADSurface(HBObj))
                    else:
                        geoRadFile.write(self.RADNonPlanarSurface(HBObj))
                        if not HBObj.isChild and HBObj.hasChild:
                            geoRadFile.write(self.RADNonPlanarChildSurface(HBObj))
                
                elif HBObj.objectType == "HBIES":
                    IESCount += 1
                    IESObjcIsFine = True
                    # check if the object has been move or scaled
                    if HBObj.checkIfScaledOrRotated(originalHBObjects[objCount]):
                        IESObjcIsFine = False
                        msg = "IES luminaire " + HBObj.name + " is scaled or rotated" + \
                              " and cannot be added to the scene."
                        print (msg)
                        self.component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)
                    
                    # check if the material name is already exist
                    if HBObj.name in customRADMat.keys():
                        IESObjcIsFine = False
                        msg = "IES luminaire " + HBObj.name + " cannot be added to the scene.\n" + \
                                  "A material with the same name already exist."
                        print (msg)
                        self.component.AddRuntimeMessage(gh.GH_RuntimeMessageLevel.Warning, msg)
                    
                    # if it is all fine then write the geometry
                    if IESObjcIsFine:
                        IESName = HBObj.name + "_" + str(IESCount)
                        geoRadFile.write( HBObj.getRADGeometryStr(IESName, originalHBObjects[objCount]))
                        # downlight_light polygon downlight.d
                        # add to IES Objects list so I can add the materials to the list later
                        if HBObj.name not in IESObjects.keys():
                            IESObjects[HBObj.name] = HBObj
                    
        geoRadFile.close()
        
        ########################################################################
        ######################## GENERATE THE BASE RAD FILE ####################
        materialFileName = subWorkingDir + "\\material_" + radFileName + '.rad'
        # This part should be fully replaced with the new method where I generate the materials from the 
        
        # 0.1 material string
        matStr =  "# start of generic materials definition(s)\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Context_Material') + "\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Interior_Ceiling') + "\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Interior_Floor') + "\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Exterior_Floor') + "\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Exterior_Window') + "\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Interior_Window') + "\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Exterior_Roof') + "\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Exterior_Wall') + "\n" + \
            self.hb_RADMaterialAUX.getRADMaterialString('Interior_Wall') + "\n" + \
            "# end of generic materials definition(s)\n"
    
        with open(materialFileName, 'w') as matFile:
            matFile.write(matStr)
            matFile.write("\n# start of material(s) specific to this study (if any)\n")
            for radMatName in customRADMat.keys():
                
                try:
                    matFile.write(self.hb_RADMaterialAUX.getRADMaterialString(radMatName) + "\n")
                except:
                    # This is the case for void material
                    pass
                
                # check if the material is is trans
                if self.hb_RADMaterialAUX.getRADMaterialType(radMatName) == "trans":
                    # get the st value
                    st = self.hb_RADMaterialAUX.getSTForTransMaterials(radMatName)

                    if st < radParameters["_st_"]:
                        print ("Found a trans material... " + \
                              "Resetting st parameter from " + str(radParameters["_st_"]) + " to " + str(st))
                        radParameters["_st_"] = st
                    
            # write mixedfun if any
            for radMatName in customMixFunRadMat.keys():
                matFile.write(self.hb_RADMaterialAUX.getRADMaterialString(radMatName) + "\n")
            
            # write IES material if any
            if len(IESObjects.keys())!= 0:
                for IESName in IESObjects.keys():
                    IESObj = IESObjects[IESName]
                    # write material file
                    matFile.write(IESObj.materialStr)
                    
                    # add dat file to folder
                    datFileName = subWorkingDir + "\\" + IESName + '.dat'
                    with open(datFileName, "w") as outDat:
                        outDat.write(IESObj.datFile)
                    
            matFile.write("# end of material(s) specific to this study (if any)\n")
    
        
        # export dayism shading geometries as radFiles
        # this is only useful for dynamic shadings
        dynamicCounter = 0
        if simulationType == 2:
            dynamicShadingRecipes = analysisRecipe.DSParameters.DShdR
            
            if  len(dynamicShadingRecipes) == 0: return radFileFullName, materialFileName
            
            customRADMat = {} # dictionary to collect the custom material names
            customMixFunRadMat = {} # dictionary to collect the custom mixfunc material names
            
            for shadingRecipe in dynamicShadingRecipes:
                
                if shadingRecipe.type == 2:
                    
                    groupName = shadingRecipe.name
                    
                    dynamicCounter+=1
                    for stateCount, shadingState in enumerate(shadingRecipe.shadingStates):
                        
                        fileName = groupName + "_state_" + str(stateCount + 1) + ".rad"
                        
                        try:
                            radStr = ""
                            
                            shdHBObjects = hb_hive.callFromHoneybeeHive(shadingState.shdHBObjects)
                            
                            for HBObj in shdHBObjects:
                                # collect the custom material informations
                                if HBObj.RadMaterial!=None:
                                        customRADMat, customMixFunRadMat = self.hb_RADMaterialAUX.addRADMatToDocumentDict(HBObj, customRADMat, customMixFunRadMat)
            
                                if HBObj.isPlanar and (not HBObj.isChild and len(HBObj.childSrfs)<2):
                                    radStr += self.RADSurface(HBObj)
                                else:
                                    radStr += self.RADNonPlanarSurface(HBObj)
                                    if not HBObj.isChild and HBObj.hasChild:
                                        # collect the custom material informations
                                        for childSrf in HBObj.childSrfs:
                                            if childSrf.RadMaterial!=None:
                                                customRADMat, customMixFunRadMat = self.hb_RADMaterialAUX.addRADMatToDocumentDict(childSrf, customRADMat, customMixFunRadMat)
                                        radStr += self.RADNonPlanarChildSurface(HBObj)
                            
                            
                            # write the shading file
                            with open(subWorkingDir + "\\" + fileName, "w") as radInf:
                                radInf.write(matStr)
                                radInf.write("# material(s) specific to this study\n")
                                for radMatName in customRADMat.keys():
                                    radInf.write(self.hb_RADMaterialAUX.getRADMaterialString(radMatName) + "\n")
                                # write mixedfun if any
                                for radMatName in customMixFunRadMat.keys():
                                    radInf.write(self.hb_RADMaterialAUX.getRADMaterialString(radMatName) + "\n")
                                radInf.write(radStr)
                                
                        except Exception, e:
                            # print `e`
                            # None object so just create an empty file
                            with open(subWorkingDir + "\\" + fileName , "w") as radInf:
                                radInf.write("#empty shading file")
                            pass    
    
        return radFileFullName, materialFileName
    
    def writeTestPtFile(self, subWorkingDir, radFileName, numOfCPUs, analysisRecipe):
        
        if analysisRecipe.type == 0: return [], [] #image-based simulation
        
        testPoints = copy.deepcopy(analysisRecipe.testPts)
        ptsNormals = copy.deepcopy(analysisRecipe.vectors)
        
        # write a pattern file which I can use later to re-branch the points
        ptnFileName = os.path.join(subWorkingDir, radFileName + '.ptn')
        
        with open(ptnFileName, "w") as ptnFile:
            for ptList in testPoints:
                ptnFile.write(str(len(ptList)) + ", ")
        
        # faltten the test points and make a copy
        flattenTestPoints = [pt for pt in self.lb_preparation.flattenList(testPoints)]
        flattenPtsNormals = [v for v in self.lb_preparation.flattenList(ptsNormals)]
    
        # if this is an annual analysis and north is not 0 rotate all Honeybee objects
        if analysisRecipe.type == 2 and analysisRecipe.northDegrees!=0:
            print ("Rotating test points for %d degrees"%analysisRecipe.northDegrees)
            
            transform = rc.Geometry.Transform.Rotation(math.radians(analysisRecipe.northDegrees), \
                        rc.Geometry.Point3d.Origin)
            
            for pt in flattenTestPoints: pt.Transform(transform)
            for v in flattenPtsNormals: v.Transform(transform)    
    
        numOfPoints = len(flattenTestPoints)
    
        if numOfCPUs > numOfPoints: numOfCPUs = numOfPoints

        if numOfCPUs > 1:
            ptsEachCpu = int(numOfPoints/(numOfCPUs))
            remainder = numOfPoints%numOfCPUs
        else:		
            ptsEachCpu = numOfPoints		
            remainder = 0
    
        lenOfPts = []
        
        for cpuCount in range(numOfCPUs):		
            if cpuCount < remainder:		
                lenOfPts.append(ptsEachCpu+1)		
            else:		
                lenOfPts.append(ptsEachCpu)
        
        testPtsEachCPU = []
        
        for cpuCount in range(numOfCPUs):
            # write pts file
            ptsForThisCPU = []
            ptsFileName = os.path.join(subWorkingDir, radFileName + '_' + `cpuCount` + '.pts')
            
            ptsFile = open(ptsFileName, "w")

            for ptCount in range(sum(lenOfPts[:cpuCount]), sum(lenOfPts[:cpuCount+1])):
                ptsFile.write(self.hb_writeRADAUX.testPtsStr(flattenTestPoints[ptCount], flattenPtsNormals[ptCount]))
                ptsForThisCPU.append(flattenTestPoints[ptCount])

            ptsFile.close()
            
            testPtsEachCPU.append(ptsForThisCPU)        
            
        return testPtsEachCPU, lenOfPts
    
    def writeBatchFiles(self, subWorkingDir, radFileName, radSkyFileName, \
                        radFileFullName, materialFileName, \
                        numOfCPUs, testPtsEachCPU, \
                        lenOfPts, analysisRecipe, additionalRadFiles, \
                        readyOCTFile = None, runOverture = True):
        
        batchFiles = []
        fileNames = [] # list of only names of the files
        pcompFileName = ""
        
        # initiate RAD Parameters
        if analysisRecipe.radParameters==None:
            quality = 0
            analysisRecipe.radParameters = {}
            print ("Default values are set for RAD parameters")
            for key in self.hb_radParDict.keys():
                #print key + " is set to " + str(hb_radParDict[key][quality])
                analysisRecipe.radParameters[key] = self.hb_radParDict[key][quality]
        
        if analysisRecipe.type == 2: # annual daylight analysis - Daysim
            # read parameters
            runAnnualGlare = analysisRecipe.DSParameters.runAnnualGlare
            onlyAnnualGlare = analysisRecipe.DSParameters.onlyAnnualGlare
            annualGlareViews = analysisRecipe.DSParameters.RhinoViewsName
            outputUnits = analysisRecipe.DSParameters.outputUnits
            adaptiveZone = analysisRecipe.DSParameters.adaptiveZone
            dgp_imageSize = analysisRecipe.DSParameters.dgp_imageSize
            dynamicShadingRecipes = analysisRecipe.DSParameters.DShdR
            numOfIllFiles = analysisRecipe.DSParameters.numOfIll
            northAngleRotation = analysisRecipe.northDegrees
            
            # empty list for result file names
            DSResultFilesAddress = []
            
            # location string
            epwFileAddress = analysisRecipe.weatherFile
            
            locationStr, locName = self.hb_writeDS.DSLocationStr(self.hb_writeRADAUX, self.lb_preparation, epwFileAddress)
            
            newLocName = self.lb_preparation.removeBlankLight(locName)
            newLocName = newLocName.replace("/", "_")
            
            # copy .epw file to sub-directory
            self.lb_preparation.copyFile(epwFileAddress, subWorkingDir + "\\" + newLocName + '.epw')
            
            pathStr = "SET RAYPATH=.;" + self.hb_RADLibPath + ";" + self.hb_DSPath + ";" + \
                      self.hb_DSLibPath + ";\nPATH=" + self.hb_RADPath + ";" + \
                      self.hb_DSPath + ";" + self.hb_DSLibPath + ";$PATH\n"
            
            heaFileName = os.path.join(subWorkingDir, radFileName + '_0.hea')
            
            initBatchFileName = os.path.join(subWorkingDir, radFileName + '_InitDS.bat')
            
            initBatchFile = open(initBatchFileName, "w")
            initBatchFile.write(pathStr)
            initBatchStr =  os.path.splitdrive(self.hb_DSPath)[0] + '\n' + \
                            'CD ' + self.hb_DSPath + '\n' + \
                            'epw2wea  ' + subWorkingDir + "\\" + self.lb_preparation.removeBlankLight(locName) + '.epw ' + subWorkingDir + "\\" +  self.lb_preparation.removeBlankLight(locName) + '.wea\n' + \
                            ':: 1. Generate Daysim version of Radiance Files\n' + \
                            'radfiles2daysim ' + heaFileName + ' -m -g\n'
            
            # rotate scene if angle is not 0!
            #if northAngleRotation!=0:
            #    initBatchStr += \
            #    ':: 1.5. Roate geometry and test points\n' + \
            #    'rotate_scene ' + heaFileName + '\n'
            
            if runAnnualGlare:
                initBatchStr += \
                ':: 2. Generate Values for annual glare\n' + \
                'gen_dgp_profile ' + heaFileName
                
            initBatchFile.write(initBatchStr)
            initBatchFile.close()
            
            # annual glare only needs one headeing file and will run on a single cpu
            if runAnnualGlare: # and onlyAnnualGlare:
                numOfCPUs = 1
                
            # write the rest of the files
            for cpuCount in range(numOfCPUs):
                heaFileName = os.path.join(subWorkingDir, radFileName + '_' + `cpuCount` + '.hea')
                heaFile = open(heaFileName, "w")
                projectName =  radFileName
                
                tempDirName = subWorkingDir + '\\tmp_' + `cpuCount`
                heaFile.write(self.hb_writeDS.DSHeadingStr(projectName, subWorkingDir, tempDirName, self.hb_DSCore , cpuCount))
                
                # delete the files in the old temp folder
                tempWorkingDir = self.lb_preparation.makeWorkingDir(tempDirName)
                
                heaFile.write(locationStr)
                
                heaFile.write(self.hb_writeDS.DSAnalysisUnits(outputUnits, lenOfPts[cpuCount]))
                
                # write view for annual glare if any
                glareViewFileName = subWorkingDir + '\\' + projectName + '_' + 'annualGlareView.vf'
                vfFile = open(glareViewFileName, "w")
                vfFile.write('')
                for view in annualGlareViews:
                    viewLine = self.hb_writeRADAUX.exportView(view, analysisRecipe.radParameters, 1, [dgp_imageSize, dgp_imageSize])
                    # I'm not sure why Daysim view file needs rview Perspective at the start line
                    vfFile.write("rview Perspective " + viewLine + "\n")
                vfFile.close()
                
                # building string
                heaFile.write(self.hb_writeDS.DSBldgStr(projectName, materialFileName, radFileFullName, \
                                                        adaptiveZone, dgp_imageSize, dgp_imageSize, cpuCount, \
                                                        northAngleRotation, additionalRadFiles))
                
                # radiance parameters string
                heaFile.write(self.hb_writeDS.DSRADStr(analysisRecipe.radParameters))
                
                # dynamic simulaion options
                heaFile.write(self.hb_writeDS.DSDynamicSimStr(dynamicShadingRecipes, projectName, subWorkingDir, testPtsEachCPU[cpuCount], cpuCount))
                
                # heaFile.write(hb_writeDS.resultStr(projectName, cpuCount))
                heaFile.close()
                
                if not(runAnnualGlare and onlyAnnualGlare):
                    # ill files
                    DSResultFilesAddress.append(os.path.join(subWorkingDir, radFileName + '_' + `cpuCount` + '.ill'))
                    # 3.  write the batch file
                    DSBatchFileName = os.path.join(subWorkingDir, radFileName + '_' + `cpuCount` + '_DS.bat')
                    DSBatchFile = open(DSBatchFileName, "w")
                    
                    fileNames.append(DSBatchFileName.split("\\")[-1])
                    
                    heaFileName = os.path.join(subWorkingDir, radFileName + '_' + `cpuCount` + '.hea')
                    
                    #SET PATH = " + subWorkingDir + "\n" + workingDrive +"\n"
                    DSBatchFile.write(pathStr)
                    
                    DSBatchStr = ':: Calculate Daylight Coefficient File (*.dc)\n' + \
                                'gen_dc ' + heaFileName + ' -dif\n' + \
                                'gen_dc ' + heaFileName + ' -dir\n' + \
                                'gen_dc ' + heaFileName + ' -paste\n' + \
                                '\n' + \
                                ':: Generate Illuminance Files (*.ill)\n' + \
                                'ds_illum  ' + heaFileName + '\n'
                    
                    DSBatchFile.write(DSBatchStr)
                                
                    DSBatchFile.close()        
                    
                    batchFiles.append(DSBatchFileName)
        
            return initBatchFileName, batchFiles, fileNames, pcompFileName, DSResultFilesAddress
        
        ######################## NOT ANNUAL SIMULATION #######################
        # 3.  write the batch file
        HDRFileAddress = []
        if analysisRecipe.type == 0:
            self.rhinoViewNames = analysisRecipe.viewNames
            # image based
            initBatchFileName = os.path.join(subWorkingDir, radFileName + '_IMGInit.bat')
            if readyOCTFile ==None:
                OCTFileName = radFileName + '_IMG'
            else:
                OCTFileName = (".").join(os.path.basename(readyOCTFile).split(".")[:-1])
            
        else:
            # not annual and not image based
            initBatchFileName = os.path.join(subWorkingDir, radFileName + '_RADInit.bat')
            if readyOCTFile ==None:
                OCTFileName = radFileName + '_RAD'
            else:
                OCTFileName = (".").join(os.path.basename(readyOCTFile).split(".")[:-1])
            
        
        # create the batch file that initiate the simulation
        with open(initBatchFileName, "w") as batchFile:
            # write the path string (I should check radiance to be installed on the system
            pathStr = "SET RAYPATH=.;" + self.hb_RADLibPath + "\nPATH=" + self.hb_RADPath + ";$PATH\n"
            batchFile.write(pathStr)
            
            batchFile.write(os.path.splitdrive(subWorkingDir)[0]  + "\n")
            batchFile.write("cd " + subWorkingDir + "\n")
            
            # write OCT file
            # 3.2. oconv line
            sceneRadFiles = [materialFileName, radSkyFileName, radFileFullName]
            
            if additionalRadFiles:
                for additionalFile in additionalRadFiles:
                    if additionalFile!=None:
                        sceneRadFiles.append(additionalFile)
                
            OCTLine = self.hb_writeRADAUX.oconvLine(OCTFileName, sceneRadFiles)
            if readyOCTFile ==None: batchFile.write(OCTLine)
            
            if analysisRecipe.type == 0:
                # add overture line in case it is an image-based analysis
                view = sc.doc.Views.ActiveView.ActiveViewport.Name
                
                viewLine = self.hb_writeRADAUX.exportView(view, analysisRecipe.radParameters, analysisRecipe.cameraType, imageSize = [64, 64])
                        
                # write rpict lines
                overtureLine = self.hb_writeRADAUX.overtureLine(viewLine, OCTFileName, view, analysisRecipe.radParameters, int(analysisRecipe.type))
                if runOverture: batchFile.write(overtureLine)
            
        if analysisRecipe.type == 0:
            # write view files
            if len(self.rhinoViewNames)==0:
                self.rhinoViewNames = [sc.doc.Views.ActiveView.ActiveViewport.Name]
            
            #recalculate vh and vv
            nXDiv = int(math.sqrt(numOfCPUs))

            while numOfCPUs%nXDiv !=0 and nXDiv < numOfCPUs:
                nXDiv += 1
            
            nYDiv = numOfCPUs/nXDiv

            fileNames = []
            HDRPieces = {}
            for cpuCount in range(numOfCPUs):
                # create a batch file
                batchFileName = os.path.join(subWorkingDir, radFileName + '_' + `cpuCount` + '_IMG.bat')
                batchFiles.append(batchFileName)
                
                fileNames.append(batchFileName.split("\\")[-1])
                batchFile = open(batchFileName, "w")
                # write path files
                batchFile.write(pathStr)
                batchFile.write(os.path.splitdrive(subWorkingDir)[0] + "\n")
                batchFile.write("cd " + subWorkingDir + "\n")
                
                # calculate vs and vl for thi cpu
                try: vs = (((cpuCount%nXDiv)/(nXDiv-1)) - 0.5) * (nXDiv - 1)
                except: vs = 0
                    
                try: vl = ((int(cpuCount/nXDiv)/(nYDiv-1)) - 0.5) * (nYDiv - 1)
                except: vl = 0
                
                # print vs, vl
                for view in self.rhinoViewNames:
                    view = self.lb_preparation.removeBlank(view)
                    
                    if cpuCount == 0:
                        HDRFileAddress.append(subWorkingDir + "\\" + OCTFileName + "_" + view + ".HDR")
                        HDRPieces[OCTFileName + "_" + view + ".HDR"] = []
                    
                    # collect name of the pieces of the picture
                    HDRPieces[OCTFileName + "_" + view + ".HDR"].append(OCTFileName + "_" + view + "_" + `cpuCount` + ".HDR")
                    
                    viewLine = self.hb_writeRADAUX.exportView(view, analysisRecipe.radParameters, analysisRecipe.cameraType, \
                                                              analysisRecipe.imageSize, analysisRecipe.sectionPlane, \
                                                              nXDiv, nYDiv, vs, vl)
                    
                    # write rpict lines
                    RPICTLines = self.hb_writeRADAUX.rpictLine(viewLine, OCTFileName, view, analysisRecipe.radParameters, int(analysisRecipe.simulationType), cpuCount)
                    batchFile.write(RPICTLines)                    
                    
                # close the file
                batchFile.close()
                
                # PCOMP to merge images into a single HDR
                pcompFileName = os.path.join(subWorkingDir, radFileName + '_PCOMP.bat')
                                
                with open(pcompFileName, "w") as pcompFile:
                    
                    # write path files
                    pcompFile.write(pathStr)
                    pcompFile.write(os.path.splitdrive(subWorkingDir)[0] + "\n")
                    pcompFile.write("cd " + subWorkingDir + "\n")
                    
                    for mergedName, pieces in HDRPieces.items():
                        
                        pcomposLine = "pcompos -a " + `nXDiv` + " "
                        # pieces.reverse()
                        for piece in pieces:
                            pcomposLine += piece + " "
                        pcomposLine += " > " + mergedName + "\n"
                        
                        pcompFile.write(pcomposLine)
            
            return initBatchFileName, batchFiles, fileNames, pcompFileName, HDRFileAddress
                        
        else:
            fileNames = []
            RADResultFilesAddress = []
            for cpuCount in range(numOfCPUs):
                # create a batch file
                batchFileName = os.path.join(subWorkingDir, radFileName + '_' + `cpuCount` + '_RAD.bat')
                batchFiles.append(batchFileName)
                
                RADResultFilesAddress.append(os.path.join(subWorkingDir, radFileName + '_' + `cpuCount` + '.res'))
                
                fileNames.append(batchFileName.split("\\")[-1])
                batchFile = open(batchFileName, "w")
                # write path files
                batchFile.write(pathStr)
                batchFile.write(os.path.splitdrive(subWorkingDir)[0] + "\n")
                batchFile.write("cd " + subWorkingDir + "\n")
                
                # 3.4. add rtrace lin
                RTRACELine = self.hb_writeRADAUX.rtraceLine(radFileName, OCTFileName, analysisRecipe.radParameters, int(analysisRecipe.simulationType), cpuCount)
                batchFile.write(RTRACELine)
                
                # close the file
                batchFile.close()
            
            
            return initBatchFileName, batchFiles, fileNames, pcompFileName, RADResultFilesAddress
        
    def executeBatchFiles(self, batchFileNames, maxPRuns = None, shell = False, waitingTime = 0.5):
    
        """Run a number of batch files in parallel and
            wait to end of the analysis.
    
            Args:
                batchFileNames: List of batch files
                maxPRuns: max number of files to be ran in parallel (default = 0)
                shell: set to True if you do NOT want to see the cmd window while the analysis is runnig
        """
    
        if not maxPRuns : maxPRuns = 1
        maxPRuns = int(maxPRuns)
        total = len(batchFileNames)
        
        if maxPRuns < 1: maxPRuns = 1
        if maxPRuns > total: maxPRuns = total
        
        running = 0
        done = False
        jobs = []
        pid = 0
        
        try:
            while not done:
                if running < maxPRuns and pid < total:
                    # execute the files
                    jobs.append(subprocess.Popen(batchFileNames[pid].replace("\\", "/") , shell = shell))
                    pid+=1
                    time.sleep(waitingTime)
                
                # count how many jobs are running and how many are done
                running = 0
                finished = 0
                for job in jobs:
                    if job.poll() is None:
                        #one job is still running
                        running += 1
                    else:
                        finished += 1
        
                if running == maxPRuns:
                    # wait for half a second
                    #print "waiting..."
                    time.sleep(waitingTime)
        
                if finished ==  total:
                    done = True
        
        except Exception, e:
            print ("Something went wrong: %s"%str(e) )
    
    def runBatchFiles(self, initBatchFileName, batchFileNames, fileNames, \
                      pcompBatchFile, waitingTime, runInBackground = False):
        
        self.executeBatchFiles([initBatchFileName], maxPRuns = 1, shell = runInBackground, waitingTime = waitingTime)
        self.executeBatchFiles(batchFileNames, maxPRuns = len(batchFileNames), shell = runInBackground, waitingTime = waitingTime)
        
        if pcompBatchFile!="":
            os.system(pcompBatchFile) # put all the files together
        
    def collectResults(self, subWorkingDir, radFileName, numOfCPUs, analysisRecipe, expectedResultFiles):
        
        if analysisRecipe.type == 2:
            #annual simulation
            runAnnualGlare = analysisRecipe.DSParameters.runAnnualGlare
            onlyAnnualGlare = analysisRecipe.DSParameters.onlyAnnualGlare
            numOfIllFiles = analysisRecipe.DSParameters.numOfIll
            annualGlareViews = analysisRecipe.DSParameters.RhinoViewsName
            DSResultFilesAddress = []
            
            if not(runAnnualGlare and onlyAnnualGlare):
                # read the number of .ill files
                # and the number of .dc files
                if subWorkingDir[-1] == os.sep: subWorkingDir = subWorkingDir[:-1]
                startTime = time.time()
                
                # check if the results are available
                files = os.listdir(subWorkingDir)
                numIll = 0
                numDc = 0
                for file in files:
                    if file.EndsWith('ill'):
                        DSResultFilesAddress.append(os.path.join(subWorkingDir, file))
                        numIll+=1
                    elif file.EndsWith('dc'):
                        numDc+=1
                # /2 in case of conceptual dynamic blinds in Daysim
                if numIll!= numOfCPUs * numOfIllFiles or not \
                    (numDc == numOfCPUs * numOfIllFiles or \
                    numDc == numOfCPUs * numOfIllFiles /2):
                    print ("Can't find the results for the study")
                    DSResultFilesAddress = []
            
            # check for results of annual glare analysis if any
            annualGlareResults = {}
            for view in annualGlareViews:
                if view not in annualGlareResults.keys():
                    annualGlareResults[view] = []
                    
            dgpFile = os.path.join(subWorkingDir, radFileName + '_0.dgp')
            
            if runAnnualGlare and os.path.isfile(dgpFile):
                with open(dgpFile, "r") as dgpRes:
                    for line in dgpRes:
                        try:
                            hourlyRes = line.split(" ")[4:]
                            # for each view there should be a number
                            for view, res in zip(annualGlareViews, hourlyRes):
                                annualGlareResults[view].append(res.strip())
                        except:
                            pass
                            
            return DSResultFilesAddress, annualGlareResults
        
        elif analysisRecipe.type == 0:
            # image-based analysis
            return expectedResultFiles
        
        else:
            RADResultFilesAddress = expectedResultFiles
            # grid-based analysis
            numRes = 0
            files = os.listdir(subWorkingDir)
            for file in files:
                if file.EndsWith('res'): numRes+=1
            if numRes != numOfCPUs:
                print ("Cannot find the results of the study")
                RADResultFilesAddress = []
            time.sleep(1)
            return RADResultFilesAddress
        
    def shiftList(self, list, number = 1):
        newList = []
        newList.extend(list[-number:])
        newList.extend(list[:-number])
        return newList
    
    def getsurfaceStr(self, surface, count, coordinates):
        if surface.RadMaterial != None:
            surface.construction = surface.RadMaterial
        elif not hasattr(surface, 'construction'):
            
            if not hasattr(surface, 'type'):
                # find the type based on 
                surface.type = surface.getTypeByNormalAngle()
                
            #assign the construction based on type
            surface.construction = surface.cnstrSet[surface.type]
            
        srfStr =  surface.construction.replace(" ", "_") + " polygon " + surface.name + '_' + `count` + "\n" + \
            "0\n" + \
            "0\n" + \
            `(len(coordinates)*3)` + "\n"
            
        ptStr = ''
        for  pt in coordinates:
            ptStr = ptStr + '%.4f'%pt.X + '  ' + '%.4f'%pt.Y + '  ' + '%.4f'%pt.Z + '\n'
        ptStr = ptStr + '\n'
        
        # check for polygons with only two points.
        # Yes! it is possible. Import a model from REVIT/SketchUp and create some breps out of it
        # and you will get some!
        if len(coordinates) < 3:
            comment = " Polygon " + surface.name + " has less than 3 vertices and is removed by Honeybee.\n"
            return "#" + comment
        
        return srfStr + ptStr

    def RADSurface(self, surface):
        fullStr = ''
        # base surface coordinates
        coordinatesList = surface.extractPoints(1, True)
        
        if coordinatesList:
            if type(coordinatesList[0])is not list and type(coordinatesList[0]) is not tuple:
                coordinatesList = [coordinatesList]
                
            for count, coordinates in enumerate(coordinatesList):
                endCoordinate = rc.Geometry.Point3d.Add(coordinates[-1], rc.Geometry.Vector3d(0,0,0))
                if surface.hasChild:
                    glzCoordinateLists = surface.extractGlzPoints(True)
                    for glzCount, glzCoorList in enumerate(glzCoordinateLists):
                        # glazingStr
                        fullStr = fullStr + self.getsurfaceStr(surface.childSrfs[0], glzCount, glzCoorList)
                        
                        # shift glazing list
                        glzCoorList = self.shiftList(glzCoorList)
                        coordinates.extend(glzCoorList)
                        coordinates.append(glzCoorList[0])
                    coordinates.extend([endCoordinate, coordinates[0]])
                fullStr = fullStr + self.getsurfaceStr(surface, count, coordinates)
            return fullStr
        else:
            print ("one of the surfaces is not exported correctly")
            return ""
            
    def RADNonPlanarSurface(self, surface):
        fullStr = ''
        
        # replace the geometry with the punched geometry
        # for planar surfaces with multiple openings
        try:
            if surface.punchedGeometry!=None:
                surface.geometry = surface.punchedGeometry
                surface.hasInternalEdge = True
        except:
            #print e
            # nonplanar surfaces with no openings
            pass
            
        # base surface coordinates
        coordinatesList = surface.extractPoints(1, True)

        if type(coordinatesList[0])is not list and type(coordinatesList[0]) is not tuple:
            coordinatesList = [coordinatesList]
        for count, coordinates in enumerate(coordinatesList):
            #print count
            fullStr = fullStr + self.getsurfaceStr(surface, count, coordinates)
        
        return fullStr
    
    def RADNonPlanarChildSurface(self, surface):
        fullStr = ''
        
        # I should test this function before the first release!
        # Not sure if it will work for cases generated only by surface
        # should probably check for meshed surface and mesh the geometry
        # in case it is not meshed
        
        # base surface coordinates
        coordinatesList = surface.extractGlzPoints(True)
        if type(coordinatesList[0])is not list and type(coordinatesList[0]) is not tuple:
            coordinatesList = [coordinatesList]
        for glzCount, glzCoorList in enumerate(coordinatesList):
            # glazingStr
            fullStr = fullStr + self.getsurfaceStr(surface.childSrfs[0], glzCount, glzCoorList)
        return fullStr

#Storing cwd for resetting it later.
currfolder = os.getcwd()


#If no values are provided for a file set them as per the start or end variable. If values are provided, then accept those.
def setvalue(variable,filename,start=None,end=None):
    if variable:
        assert os.path.exists(variable),"The file %s does not exist"%variable
    else:
        assert os.path.exists(filename),"The file %s does not exist"%filename
        if start:
            if filename.startswith(start):
                return os.path.abspath(filename)
        elif end:
            if filename.endswith(end):
                return os.path.abspath(filename)
        return os.path.abspath(filename)
    

#illumThreshold and hoursThreshold as per LM 83-12 are 1000 and 250. They can be changed to a custom level.
if _illumThreshold_ is None:
    _illumThreshold_ = 1000 

if _hoursThreshold_ is None:
    _hoursThreshold_ = 250 


if _run and _studyFolder and _HBObjects and _analysisRecipe:

        if os.path.isdir(_studyFolder):
            os.chdir(_studyFolder)
            #Create ase folder if it does not already exist. Will overwrite existing files.
            if not os.path.exists('ase'):
                os.mkdir('ase')

            os.chdir('ase')

            
            writeRad = hb_WriteRAD(ghenv.Component)
            meshParameters = None
            exportAirWalls = None
            studySubDir = os.path.join(_studyFolder,'ase')
            
            testPtsEachCPU,lenOfPts = writeRad.writeTestPtFile(studySubDir,'ASE',1,_analysisRecipe)
            radFileFullName,materialFileName = writeRad.writeRADAndMaterialFiles(_HBObjects, studySubDir,\
                                                         'geometry.rad', _analysisRecipe, \
                                                         meshParameters, exportAirWalls)
            
            
            _materialsFile_ = materialFileName
            _geometryFile_ = radFileFullName
            _epwFile_ = _analysisRecipe.weatherFile
            _ptsFile_ = os.path.join(os.getcwd(),'ASE_0.pts')
            
            #Create analemma geometry and sky matrix.
            os.system('dxanalemma -f {} -m sunmat.rad -g sungeo.rad -s suns.smx'.format(_epwFile_))

            #get the list of suns for rcontrib.Create a separate rad file containing the sun material and sun files.
            with open('sunlist.txt','w') as sunfile,open('sunpaths.rad','w') as sunpaths:
                with open('sunmat.rad') as sunmat:
                    for lines in sunmat:
                        print(lines.split()[2],file=sunfile)
                        print(lines.strip(),file = sunpaths)
                with open('sungeo.rad') as sungeo:
                    for lines in sungeo:
                        print(lines.strip(),file = sunpaths)
        
            #This can be used in the future to see where the analemma patterns are.
            sunPathGeometry = os.path.abspath('sunpaths.rad')
            
        
            #create and run batch file.
            with open('ase.bat','w') as asebatfile:
                
                print('oconv {} {} sunmat.rad sungeo.rad > ase.oct'.format(_materialsFile_,_geometryFile_),file=asebatfile)
                
                #if rcontrib settings have been provided by the user, use those or else accept default values of ad = 10000, dc =1 and n =4
                if _rcontribSettings_:
                    print('rcontrib -ab 0 {} -I -M {}  ase.oct< {} > ase.rct'.format(_rcontribSettings_,os.path.abspath('sunlist.txt'),_ptsFile_),file=asebatfile)
                else:
                    ad,dc,n = 10000,1,4
                    print('rcontrib -ab 0 -ad {} -I -M {} -dc {} -n {} ase.oct< {} > ase.rct'.format(ad,os.path.abspath('sunlist.txt'),dc,n,_ptsFile_),file=asebatfile)
                
                print('dctimestep -h -n 8760 ase.rct suns.smx > dct.mtx',file=asebatfile)
                
                print('rcollate -h -oc 1 < dct.mtx > rcol.mtx',file=asebatfile) 
                    #rcalc
                print("rcalc -e $1=179*(.265*$1+.670*$2+.065*$3) rcol.mtx > rcalc.mtx",file=asebatfile)
                
                #rcollate
                lenOfPts = lenOfPts[0]
                print('rcollate -ir {} -or {} -h -fa1 -oc 8760 -ic 1 < rcalc.mtx > asetemp.ill'.format(8760*lenOfPts,lenOfPts),file=asebatfile)
                
                #rcollate, final.
                print('rcollate -h -fa1 -t < asetemp.ill>ase.ill',file=asebatfile)
            
            #run batch file.
            sp.call('ase.bat')
        
            hourlySummary = []
            gridSummary = []
            asearray = []
            with open('ase.ill') as asefile:
                for lines in asefile:
                    lines = lines.strip().split()
                    lines = [round(float(illvalue)) for illvalue in lines]
                    ptsAboveThreshold = len([pt for pt in lines if pt >= _illumThreshold_])
                    hourlySummary.append(ptsAboveThreshold/len(lines))
                    
                    if not gridSummary:
                        gridSummary = [0]*len(lines)
                    
                    for idx,luxlevel in enumerate(lines):
                        if luxlevel >= _illumThreshold_:
                            gridSummary[idx] += 1
                    
                    lines = " ".join(map(str,lines))
                    asearray.append(lines)
            
            ASE = len([gridpt for gridpt in gridSummary if gridpt>=_hoursThreshold_])/len(gridSummary)
            
            idx = 0
            with open(_epwFile_) as epwfile,open('ase.ill','w') as asefile:
                for lines in epwfile:
                    
                    try:
                        lines = lines.strip().split(',')
                        year = float(lines[0])
                        timestamp = " ".join(map(str,lines[1:4]))
                        asedata = timestamp + ' ' + asearray[idx]
                        print(asedata,file=asefile)
                        idx +=1
                    except ValueError:
                        pass
            annual_ASE_analysis_file = os.path.abspath('ase.ill')            
            os.chdir(currfolder)